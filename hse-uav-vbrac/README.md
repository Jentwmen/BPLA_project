# HSE UAV VBRAC



## Короткая инструкция по установке

Необходимо выполнить следующие действия:

```
cd your_workspace_directory/src
git clone https://gitlab.com/LIRS_Projects/hse-uav-vbrac.git
cd ../
catkin_make
```
Если не найден пакет, то:
```
source devel/setup.bash
```

## Описание пакета enoga

- **include** содержит заголовочные файлы (*.h)
- **src** содержит файлы реализации (*.cpp)
- **msg** содержит описание сообщений (*.msg)
- **scripts** содержит python-файлы (*.py)

## Как запустить симуляцию?
Пример запуска симуляции без использования GUI, а с использованием commands_controller_enoga и с вводом команд вручную в данной ноде:
```
roslaunch px4_sim leader_follower_multi_uav_mavros.launch
rosrun enoga commands_controller_enoga
rosrun enoga participant_enoga 0
rosrun enoga participant_enoga 1
rosrun enoga participant_enoga 2
...
rosrun enoga participant_enoga N
```
**leader_follower_multi_uav_mavros.launch** содержит модели БЛА только с нижней камерой!
0, 1, 2, ..., N  в rosrun enoga participant_enoga обозначают идентификатор БЛА, для управления которым запускается нода.

## VBRAC-SURF
Т.к. при установке PX4-LIRS NumPy должен быть уже установлен, то необходимо выполнить следующее:
```
pip install scipy
pip install shapely

```
**Архитектура взаимодействия** <br>
Сначала выполняется основная задача VBRAC - покрывается граница зоны наводнения. Далее лидер отправляет в топик "/vbrac_surf_input" массив из точек пограничных БЛА (см. сообщение points.msg). Нода, реализующая работу VBRAC-SURF читает из этого топика сообщения, формирует точки, в которых надо будет расположить внутренние БЛА, посылает в топик "/vbrac_surf_points" массив с точками для внутренних БЛА. Лидер получает эти точки и отправляет последователям, которые являются внутренними БЛА, точки, в которых последние должны расположиться.


Ноду test_node.py реализует scripts/test_node.py.
Используется основное сообщение в msg/points.msg, передающее массив точек (объектов класса geometry_msg::Point). <br>
Топик **/vbrac_surf_input**, используется для получения точек, в которых находятся пограничные БЛА. А топик **/vbrac_surf_points** используется для передачи сформированных точек для внутренних БЛА. <br>

Пример формирования сообщения points.msg с массивом точек на С++:
```
#include <ros/ros.h>
#include <vector>
#include <enoga/points.h>
#include <geometry_msgs/Point.h>

int main(int argc, char **argv) {
    ros::init(argc, argv, "test");
    ros::NodeHandle nh;
    ros::Publisher test_pub=nh.advertise<enoga::points>("/vbrac_surf_input", 10);

    enoga::points points_msg;

    std::vector<geometry_msgs::Point> points;
    geometry_msgs::Point point;
    point.x=0.3;
    point.y=5.2;
    point.z=0.0;
    points.push_back(point);

    for(std::vector<geometry_msgs::Point>::iterator it=points.begin(); it!=points.end(); ++it) {
        points_msg.points.push_back(*it);
    }

    while(ros::ok()) {
        test_pub.publish(points_msg);
        ros::spinOnce();
    }
    
}

```
Написал в test_surf.cpp ноду test_surf_enoga в качестве примера, но она менее качественно написана, реализация выше должна быть более оптимальной и приятной :)

## Описание используемых сообщение 

1. **enoga**<br>Состоит из двух полей: uint16 id и geometry_msgs/Pose location. Можно использовать для передачи позиции (XYZ) и для какого-нибудь целочисленного беззнакового числа (в своем случае я использую это поле для передачи id БЛА, которому сообщение нужно доставить).
2. **follower**<br>Состоит из двух полей: uint16 id и uint16 command. В своем случае использую для передачи id БЛА (цель изменений) и команды (флага). Например, используя такое сообщение, сообщаю всему рою, что именно этот БЛА с этим id меняет свой статус в соответствии с указанной командой, например, становится новым лидером роя или уходит на посадку из-за разрядившейся батареи.
3. **battery**<br>Состоит из полей: float32 percentage и полей времени, percentage используется непосредственно для указания процента батареи, а передаваемое время определяет время работы каждого конкретного БЛА.

## Описание используемых топиков
1. Работа с лидером происходит через топик **/commands_controller**<br>
Туда отправляются команды типа std_msgs::Int8:<br> 
- 1 - запуск винтов;<br>
- 2 - взлет (переключение в режим OFFBOARD, см. режимы PX4)
- 3 - поднять высоту на 1 (z+=1);<br>
- 4 - опустить высоту на 1 (z-=1);<br>
- 5 - сдвинуться влево на 1;<br>
- 6 - сдвинуться вправо на 1;<br>
- 7 - сдвинуться вперед на 1;<br>
- 8 - сдвинуться назад на 1;<br>
- 9 - повернуться на 90 градусов по часовой стрелке;<br>
- 10 - повернуть на 90 градусов против часовой стрелки;<br>
- -1 - переключиться в режим AUTO.RTL (не пробовал, но если память не изменяет, то возврат в точку взлета);<br>
- -2 - переключиться в режим AUTO.LAND (не пробовал, по идее, просто посадка);<br>
- -5 - подсоединить всех доступных последователей (все взлетают);<br>
- -6 - отключить всех доступных последователей (не пробовал, по идее, должны просто сесть все, кроме лидера);<br>
- -7 - следовать за лидером (не тестил, скорее всего уберем);<br>
- -9 - выставление высоты первого БЛА построения формации (конечная стадия алгоритма построения формации);<br>


2. **/formation** используется для отправки команд, означающих выбранную для построения формацию. Читает только лидер.<br>Туда отправляются команды типа std_msgs::Int8 из GUI (сейчас commands_controller):<br>
- 0 - клин;
- 1 - клин с выделением первого БЛА построения спереди;
- 2 - змейка;
- 3 - фронт;
- 4 - колонна;
- 5 - пеленг;
- 6 - фланги;
- 7 - шахматы;
- 8 - прямоугольник (полный);
- 9 - прямоугольник (пустой внутри);
- 10 - ромб;
- 11 - ромб (пустой внутри);
- 12 - сектор окружности;
- 13 - окружность;

3. **/commands_to_follower** используется для отправки команд последователям, отправляет только лидер, последователи только читают.<br>Туда уходят команды типа std_msgs::Int8 (уходят из объекта класса UAV, если это лидер)<br>
Команды см. в описании к топику **/commands_controller**.
Разница только в следующих:<br>
- -5 - включение винтов и взлет (переключение в OFFBOARD);
- -6 - посадка последователя - AUTO.LAND (убрать дубли???);

4. **/commands_to_leader** пока в разработке, должен использоваться для отправки сообщений/команд лидеру от последователей, например, о статусе последователя (заряд батареи и т.п.) ПОКА НЕ ИСПОЛЬЗУЕТСЯ, НО И НЕ УДАЛЯЕМ;

5. **/enoga_controller** используется лидером для отправки последователям? сообщений типа enoga::enoga, содержащих id БЛА и позицию для данного БЛА согласно координатной сетке, сгенерированной по алгоритму построения формаций. 

6. **/battery** используется каждым БЛА для отправки сообщений типа enoga::battery, содержащих информацию о текущем проценте заряда конкретного БЛА и о его времени работы, после вхождения в режим "OFFBOARD".


## Описание модели батареи
Преведена очень простая модель для симуляции батареи, достаточно далекая от реальной.

Всего у нее 3 характеристики:
InitialVoltage - Начальное напряжение
InternalResistance - Внутреннее сопротивление (можно измерить, только имея при себе реальную батарею)
Capacity - Емкость

При переносе проекта на реальные БЛА, данная симуляция отключается, при этом важно сохранить названия топиков, для успешной работы всего ПО.